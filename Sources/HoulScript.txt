#include <SPI.h>
#include <MFRC522.h>

#include "Data_Base.h"
#include "Terminal.h"

#define SS_PIN 5
#define RST_PIN 21
#define ANALOG_PIN 35

MFRC522 mfrc522(SS_PIN, RST_PIN);
MFRC522::StatusCode status;

Terminal terminal;
std::vector<uint8_t> received_UID;

void setup() {
  Serial.begin(9600); // Инициализация Serial-порта
  SPI.begin();          // Инициализация шины SPI
  mfrc522.PCD_Init();   // Инициализация RFID-модуля

  pinMode(ANALOG_PIN, INPUT);  // Настройка аналогового пина как вход

  mfrc522.PCD_SetAntennaGain(mfrc522.RxGain_max);  // Установка усиления антенны
  mfrc522.PCD_AntennaOff();           // Перезагружаем антенну
  mfrc522.PCD_AntennaOn();            // Включаем антенну

  delay(5000);
  Serial.print("\n");
  Serial.println("Inicialization saccess");
}

void loop() { 

  std::vector<std::string> cmd = terminal.read_command();
  if (cmd.size() > 0) {
      terminal.process_command(cmd);
  }
  delay(100);

  static uint32_t rebootTimer = millis(); // Важный костыль против зависания модуля!
  if (millis() - rebootTimer >= 1000) {   // Таймер с периодом 1000 мс
    rebootTimer = millis();               // Обновляем таймер
    digitalWrite(RST_PIN, HIGH);          // Сбрасываем модуль
    delayMicroseconds(2);                 // Ждем 2 мкс
    digitalWrite(RST_PIN, LOW);           // Отпускаем сброс
    mfrc522.PCD_Init();                      // Инициализируем заного
  }

  if (!mfrc522.PICC_IsNewCardPresent()) return; // Проверяем, поднесена ли новая метка. Если нет, выходим из loop и проверяем снова
  if (!mfrc522.PICC_ReadCardSerial()) return; // Пытаемся прочитать данные метки. Если не удалось, выходим из loop

  received_UID.clear();
  for (uint8_t  i = 0; i < mfrc522.uid.size; i++) {
    received_UID.push_back(mfrc522.uid.uidByte[i]);
  }

  terminal.buffer_UID(received_UID);
  
  // Останавливаем работу с меткой
  // mfrc522.PICC_HaltA();
  delay(1000);
}

#ifndef DATA_BASE_H
#define DATA_BASE_H

#include <map>
#include <string>

#include "Person.h"

class Data_Base {
  private:
    std::map<std::vector<uint8_t>, Person*> person_data;
  public:
    Data_Base();
    ~Data_Base();

    auto find_person(std::vector<uint8_t> person_UID);
    auto find_person(std::string person_name);
    auto find_person(int p_number);

    auto get_map_end();

    bool add_person(std::vector<uint8_t> person_UID);
    bool delete_person(std::vector<uint8_t> person_UID);
    bool delete_person(int p_number);

    void print_persons_data();
    void print_persons_data(std::string p_name);
};

bool operator==(const std::vector<uint8_t>& lhs, const std::vector<uint8_t>& rhs);

#endif

#include <iterator>
#include <Arduino.h>
#include "Data_Base.h"

std::string get_string(){
  std::string name = "";
  while (Serial.available() == 0) {
    delay(10);
  }
  while (true) {
    if (Serial.available() > 0) {
      char new_char = Serial.read();
      if (new_char == '\n' || new_char == '\r') {
        if (new_char == '\n') {
          break;
        }
      } else {
        name += new_char;
      }
      if (name.length() >= 128) {
        break;
      }
    }
    delay(1); // Небольшая задержка для стабильности
  }
  return name;
}

Data_Base::Data_Base(){
  Serial.print("Data_Base::Data_Base()\n");
}

Data_Base::~Data_Base(){
  for (auto it = person_data.begin(); it!=person_data.end(); it++){
    delete (it->second);
  }
  Serial.print("Data_Base::~Data_Base()\n");
}

bool operator==(const std::vector<uint8_t>& lhs, const std::vector<uint8_t>& rhs) {
    if (lhs.size() != rhs.size()) return false;
    for (int i = 0; i < lhs.size(); i++) {
        if (lhs[i] != rhs[i]) return false;
    }
    return true;
}

auto Data_Base::find_person(std::vector<uint8_t> person_UID){
  for (auto it = person_data.begin(); it!=person_data.end(); it++){
    if (it->first == person_UID){
      return it;
    }
  }
  return person_data.end();
}

auto Data_Base::find_person(std::string person_name){
  for (auto it = person_data.begin(); it!=person_data.end(); it++){
    if (it->second->get_name() == person_name){
      return it;
    }
  }
  return person_data.end();
}

auto Data_Base::find_person(int p_number){
  for (auto it = person_data.begin(); it!=person_data.end(); it++){
    if (it->second->get_person_number() == p_number){
      return it;
    }
  }
  return person_data.end();
}

auto Data_Base::get_map_end(){
  return person_data.end();
}

bool Data_Base::add_person(std::vector<uint8_t> person_UID){
  Serial.print("Trying to add person in Data_Base: ");
  for (int i =0; i< person_UID.size(); i++){
    Serial.print(person_UID[i]);
    Serial.print(' ');
  }
  Serial.print('\n');
  Person* person = new Person(person_UID);
  Serial.print("Enter the user`s full name\n");
  std::string p_name = get_string();
  person->rename(p_name);
  person_data[person_UID] = person;
  Serial.print("New person has been added\n");
  return true;
}

bool Data_Base::delete_person(std::vector<uint8_t> person_UID){
  auto it = find_person(person_UID);
  if (it != person_data.end()){
    delete it->second;
    person_data.erase(it);
    return true;
  }
  return false;
}

bool Data_Base::delete_person(int p_number){
  auto it = find_person(p_number);
  if (it != person_data.end()){
    delete it->second;
    person_data.erase(it);
    return true;
  }
  return false;
}

void Data_Base::print_persons_data(){
  if (person_data.size() == 0){
    Serial.print("Data_Base is empty\n");
    return;
  }
  // int i = 1;
  for (auto it = person_data.begin(); it!=person_data.end(); it++){
    Serial.print(it->second->get_person_number());
    Serial.print(") ");
    it->second->print_info();
    // Serial.print("\n");
    // i++;
  }
}

// void Data_Base::print_persons_data(std::string p_name){
//   if (person_data.size() == 0){
//     Serial.print("Data_Base is empty\n");
//     return;
//   }
//   for (auto it = person_data.begin(); it!=person_data.end(); it++){
//     if (it->second->get_name() == p_name){ // точное совпадение
//       Serial.print(it->second->get_person_number());
//       Serial.print(") ");
//       it->second->print_info();
//     }
//     std::string = 
//   }
// }

void Data_Base::print_persons_data(std::string p_name){
  if (person_data.size() == 0){
    Serial.print("Data_Base is empty\n");
    return;
  }
  bool found = false;
  for (auto it = person_data.begin(); it != person_data.end(); it++){
    std::string person_name = it->second->get_name();
    // 1. Точное совпадение
    if (person_name == p_name) {
      Serial.print(it->second->get_person_number());
      Serial.print(") ");
      it->second->print_info();
      found = true;
      continue;
    }
    // 2. Простой поиск подстроки (фамилия/имя/отчество содержатся в ФИО)
    if (person_name.find(p_name) != std::string::npos) {
      Serial.print(it->second->get_person_number());
      Serial.print(") ");
      it->second->print_info();
      found = true;
    }
  }
  if (!found) {
    Serial.print("No persons found for: ");
    Serial.println(p_name.c_str());
  }
}




#ifndef PERSON_H
#define PERSON_H

#include <string>
#include <map>
#include <vector>
#include <string>

class Person {
  private:
    std::vector<uint8_t> UID;
    std::string name = "none";
    int p_number;
    static int P_NUMBER;
    std::map<int, int> keys;
  public:
    Person(std::vector<uint8_t> person_UID);
    ~Person();

    void rename(std::string new_name);
    std::string get_name();
    int get_person_number();

    bool add_key_access(int key_number);
    bool remove_key_access(int key_number);

    bool check_key_access(int key_number);

    int get_key_status(int key_number); // 0 - inaccessible; 1 - in place; 2 - in users hands

    bool take_key(int key_number);
    bool return_key(int key_number);

    void print_info();
};

#endif

#include <Arduino.h>
#include "Person.h"

int Person::P_NUMBER = 0;

Person::Person(std::vector<uint8_t> person_UID){
  for (int i =0; i<person_UID.size(); i++){
    UID.push_back(person_UID[i]);
  }
  P_NUMBER++;
  p_number = P_NUMBER;
  // Serial.print("Person::Person()\n");
}

Person::~Person(){
  // Serial.print("Person::~Person()\n");
}

void Person::rename(std::string new_name){
  if (new_name!=""){
    name = new_name;
  }
}

std::string Person::get_name(){
  return name;
}

int Person::get_person_number(){
  return p_number;
}

bool Person::add_key_access(int key_number){
  keys[key_number] = 1;
  Serial.print("Access was given\n");
  return true;
}

bool Person::remove_key_access(int key_number){
  auto it = keys.find(key_number);
  if (it != keys.end()) {
    it->second = 0;
    Serial.print("Access removed\n");
    return true;
  } else {
    Serial.print("Person didn`t have access to this key\n");
  }
  return false;
}

bool Person::check_key_access(int key_number){
  auto it = keys.find(key_number);
  if (it != keys.end()) {
    if(it->second == 1){
      Serial.print("Key is available\n");
      return true;
    }
  } else {
    Serial.print("Key isn`t available\n");
  }
  return false;
}

int Person::get_key_status(int key_number){
  auto it = keys.find(key_number);
  if (it != keys.end()) {
    if(it->second == 0){
      Serial.print("Key isn`t available\n");
      return 0;
    } else if((it->second == 1)) {
      Serial.print("Key is available\n");
      return 1;
    } else {
      Serial.print("Key is in hands\n");
    }
  }
  return 2;
}

bool Person::take_key(int key_number){
  if (check_key_access(key_number)){
    auto it = keys.find(key_number);
    it->second = 2;
    Serial.print("Key is taken\n");
    return true;
  } else {
    Serial.print("Key is taken\n");
  }
  return false;
}


bool Person::return_key(int key_number){
  if (check_key_access(key_number)){
    auto it = keys.find(key_number);
    it->second = 1;
    Serial.print("Key was returned\n");
    return true;
  } else {
    Serial.print("Key wasn`t returned\\n");
  }
  return false;
}

void Person::print_info(){
  Serial.print("Person UID: ");
  for (int i =0; i<UID.size(); i++){
    Serial.print(UID[i]);
    Serial.print(' ');
  }
  Serial.print(" | Person name: ");
  Serial.print(name.c_str());
  Serial.print(" | Available keys: ");
  for (auto it = keys.begin(); it != keys.end(); it++){
    if (it->second == 1 || it->second == 2){
      Serial.print(it->first);
      Serial.print(" ");
    }
  }
  Serial.print(" | Keys in hands: ");
  for (auto it = keys.begin(); it!=keys.end(); it++){
    if (it->second == 2){
      Serial.print(it->first);
      Serial.print(" ");
    }
  }
  Serial.print("\n");
}



#ifndef TERMINAL_H
#define TERMINAL_H

#include <map>
#include <string>
#include <vector>

#include "Data_Base.h"

class Terminal {
  private:
    Data_Base data_base;
    std::vector<uint8_t> buffered_UID;
    // std::map<std::string, std::string> HELP;
  public:
    Terminal();
    ~Terminal();

    void process_add(std::string new_user);
    void process_info(std::vector<std::string> command);
    void process_check(std::string who);
    void process_delete(std::string who);
    void process_help();

    void process_command(std::vector<std::string> commands);
    void buffer_UID(std::vector<uint8_t>& new_UID);
    std::vector<std::string> read_command();
};

#endif

#include <iterator>
#include <Arduino.h>
#include "Terminal.h"

Terminal::Terminal(){
  Serial.print("Terminal::Terminal()\n");
}

Terminal::~Terminal(){
  Serial.print("Terminal::~Terminal()\n");
}

void Terminal::process_add(std::string new_user){
  if (!new_user.length()) return;
  if (new_user == "THIS"){
    if (buffered_UID.size()==0){
      Serial.print("There is not person\n");
      return;
    }
    data_base.add_person(buffered_UID);
  } else {
    // Serial.print(new_user.c_str());
    Serial.print("Try to use 'help'\n");
  }
}

void Terminal::process_info(std::vector<std::string> command){
  if (!command[1].size()) return;
  if (command[1] == "ALL"){
    data_base.print_persons_data();
  } else {
    std::string p_name="";
    for (int i=1; i< command.size()-1; i++){
      p_name+=command[i]; // собираем имя в единую строку
      p_name+=" ";
    }
    p_name+=command[command.size()-1];
    // Serial.print(p_name.c_str());
    // Serial.print("\n");
    data_base.print_persons_data(p_name);
    // Serial.print("Try to use 'help'\n");
  }
}

// Функция для измерения уровня сигнала на аналоговом порту
void readAnalogSignal(int pin_number) {
  int sensorValue = analogRead(pin_number);        // Чтение аналогового значения (0-1023)
  float voltage = sensorValue * (3.3 / 4095.0);    // Конвертация в напряжение (для ESP32)
  Serial.print("Pin: ");
  Serial.print(pin_number);
  // Serial.print(" | Value: ");
  // Serial.print(sensorValue);
  Serial.print(" | V: ");
  Serial.print(voltage);
  Serial.print("     ");
}

void Terminal::process_check(std::string who){
  if (!who.length()) return;
  if (who == "buffer"){
    if (buffered_UID.size() ==0){
      Serial.print("Buffer is empty\n");
      return;
    }
    Serial.print("The last buffered UID: ");
    for (int i =0; i< buffered_UID.size(); i++){
      Serial.print(buffered_UID[i]);
      Serial.print(' ');
    }
    Serial.println();
    return;
  } if (who == "voltage"){
    char new_char = ' ';
    while (new_char != '\n'){
      new_char = Serial.read();
      readAnalogSignal(35); // перечисляем все порты с которых будем считывать сигнал
      readAnalogSignal(34);
      Serial.print("press Enter to finish V-checking\n");
      delay(100);
    }
      return;
  } else {
    Serial.print("Try to use 'help'\n");
  }
}

void Terminal::process_help(){
  Serial.print("Commands list:\n");
  Serial.print("'add [THIS]' too add new person\n");
  Serial.print("'delete [person number]' too view persons data\n");
  Serial.print("'info [ALL; person name]' too view persons data\n");
  Serial.print("'check [buffer; voltage]' too view sm\n");
}

void Terminal::process_delete(std::string p_number){
  for (int i = 0; i< p_number.length(); i++){
    if(!isDigit(p_number[i])){
      Serial.print("incorrect symbol\n");
      return;
    }
  }
  Serial.print("Trying to delete person: ");
  Serial.print(p_number.c_str());
  Serial.print('\n');

  if(data_base.delete_person(std::stoi(p_number))){
    Serial.print("Successful deletion\n");
  } else {
    Serial.print("Deletion error\n");
  }

  // data_base.delete_person(std::vector<uint8_t> person_UID)
}

void Terminal::process_command(std::vector<std::string> commands){
  Serial.print('\n');
  Serial.print(">>");
  for (auto i = commands.begin(); i!= commands.end(); i++){
    Serial.print(" ");
    Serial.print(i->data());
  }
  Serial.print(":\n");
  if (commands.size() == 1){
    if (commands[0] == "help"){
      process_help();
      return;
    }
    Serial.print("Try to use 'help'\n");
    return;
  }

  std::string command = commands[0];
  if (command == "add"){
    process_add(commands[1]);
    return;
  }
  if (command == "info"){
    process_info(commands);
    return;
  }
  if (command == "check"){
    process_check(commands[1]);
    return;
  }
  if (command == "delete"){
    process_delete(commands[1]);
    return;
  } else {
    Serial.print("Unknown command\n");
  }
}

std::vector<std::string> Terminal::read_command(){
  std::vector<std::string> commands;
  if (Serial.available()) {
    std::string command = "";
    char new_char = Serial.read();
    while (new_char != '\n' && command.length()<64){
      if (new_char == ' '){
        if (!command.empty()){
          commands.push_back(command);
        }
        command = "";
      } else {
        command += new_char;
      }
      if (Serial.available()) {
        new_char = Serial.read();
      } else {
        delay(10);  // Небольшая задержка для прихода следующих символов
      }
    }
    if (!command.empty()) {
      commands.push_back(command);
    }
  }
  return commands;
}

void Terminal::buffer_UID(std::vector<uint8_t>& new_UID){
  buffered_UID.clear();
  for (int i =0; i< new_UID.size(); i++){
    buffered_UID.push_back(new_UID[i]);
  }
  Serial.print("Buffered UID: ");
  for (int i =0; i< buffered_UID.size(); i++){
    Serial.print(buffered_UID[i]);
    Serial.print(' ');
  }
  Serial.println();
}



